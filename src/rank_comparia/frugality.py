# SPDX-FileCopyrightText: 2025 Pôle d'Expertise de la Régulation Numérique <contact@peren.gouv.fr>
#
# SPDX-License-Identifier: MIT

from pathlib import Path
from typing import Literal, Optional

import altair as alt
import polars as pl

from rank_comparia.elo import ELORanker


def get_model_params(conversations: pl.DataFrame) -> pl.DataFrame:
    """
    Select infos about number of parameters of models

    Args:
        conversations (pl.DataFrame) : Conversations data.

    Returns:
        pl.DataFrame with number of parameters per model
    """
    return (
        pl.concat(
            [
                conversations.select(model_name=pl.col("model_a_name"), n_param=pl.col("model_a_active_params")),
                conversations.select(model_name=pl.col("model_b_name"), n_param=pl.col("model_b_active_params")),
            ]
        )
        .drop_nulls()
        .unique(subset="model_name", keep="first")
    )


def get_models_output_tokens(conversations: pl.DataFrame):
    """
    Calculates all output tokens generated by a model

    Args:
        conversations (pl.DataFrame) : Conversations data.

    Returns:
        pl.DataFrame with number of output tokens generated by model
    """
    return (
        pl.concat(
            [
                conversations.select(
                    model_name=pl.col("model_a_name"), total_output_tokens=pl.col("total_conv_a_output_tokens")
                ),
                conversations.select(
                    model_name=pl.col("model_b_name"), total_output_tokens=pl.col("total_conv_b_output_tokens")
                ),
            ]
        )
        .group_by("model_name")
        .sum()
        .sort(by="model_name")
        .drop_nulls()
    )


def get_n_match(ranker_score: ELORanker):
    """
    Build a DataFrame to map the number of matches played by models

    Args :
        ranker_score (ELORanker) : Ranker Class used to compute all matches

    Returns:
        polars DataFrame with 2 columns (model_name, number of matches played)
    """
    return pl.DataFrame(
        zip(ranker_score.played_matches.keys(), ranker_score.played_matches.values()), schema=["model_name", "n_match"]
    ).sort(by="model_name")


def calculate_frugality_score(conversations: pl.DataFrame, n_match: Optional[pl.DataFrame], mean: bool):
    """
    Calculate a frugality score by model from conversations data.

    Args:
        conversations (pl.DataFrame): Conversations data.
        n_match (pl.DataFrame): Data with the number of matches by model.
        mean (bool): If True, compute mean energy consumption per conversation.

    Returns:
        pl.DataFrame: DataFrame with frugality scores.
    """

    frugal_score = (
        pl.concat(
            [
                conversations.select(
                    total_output_tokens=pl.col("total_conv_a_output_tokens"),
                    model_name=pl.col("model_a_name"),
                    conso_all_conv=pl.col("total_conv_a_kwh"),
                ),
                conversations.select(
                    total_output_tokens=pl.col("total_conv_b_output_tokens"),
                    model_name=pl.col("model_b_name"),
                    conso_all_conv=pl.col("total_conv_b_kwh"),
                ),
            ]
        )
        .group_by("model_name")
        .sum()
        .sort(by="model_name")
        .drop_nulls()
    )

    if n_match is not None:
        frugal_score = frugal_score.join(n_match, on="model_name")
        if mean:
            frugal_score = frugal_score.with_columns(
                mean_conso_per_match=pl.col("conso_all_conv") / pl.col("n_match"),
            )

    if mean:
        frugal_score = frugal_score.with_columns(
            mean_conso_per_token=pl.col("conso_all_conv") / pl.col("total_output_tokens"),
        ).drop_nans()

    return frugal_score


def get_normalized_log_cost(frugal_score: pl.DataFrame) -> pl.DataFrame:
    log_frugality = frugal_score.with_columns(log_cost=pl.col("mean_conso_per_token").log(base=10))
    median_score = log_frugality.median().item(0, "log_cost")
    return log_frugality.select(model=pl.col("model_name"), cost=pl.col("log_cost") - pl.lit(median_score))


def draw_ranked_frugality(frugal_log_score: pl.DataFrame, bootstraped_scores: pl.DataFrame):
    """
    Draw chart displaying Elo scores against Elo score adjusted for frugality.

    Args:
        frugal_log_score (pl.DataFrame): DataFrame with frugality score.
        bootstraped_scores (pl.DataFrame): DataFrame with bootstraped scores

    Returns:
        alt.Chart: chart displaying Elo scores against Elo score adjusted for frugality.
    """
    all_data = bootstraped_scores.select(["model", "median"]).join(frugal_log_score, on="model")
    all_data_frugal = all_data.with_columns(frugal=(pl.col("median") - 366 * pl.col("cost")))
    max_frugal = all_data_frugal.max().item(0, "frugal") // 100 * 100 + 100
    min_frugal = all_data_frugal.min().item(0, "frugal") // 100 * 100
    max_elo = all_data_frugal.max().item(0, "median") // 100 * 100 + 100
    min_elo = all_data_frugal.min().item(0, "median") // 100 * 100

    # Construction of a slider to adjust how much we want to take into account frugality in scoring
    bind_range = alt.binding_range(min=0, max=1, name="frugality coefficient:  ")
    param_width = alt.param(bind=bind_range, value=1)

    x = alt.X("median").title("elo score").scale(type="linear").scale(domainMin=min_elo, domainMax=max_elo)
    y = alt.Y("y:Q").title("frugality elo score").scale(domainMin=min_frugal, domainMax=max_frugal)
    return (
        alt.Chart(all_data)
        .mark_point(tooltip=True)
        .encode(x=x, y=y, color=alt.Color("model:N"))
        .add_params(
            param_width,
        )
        .transform_calculate(
            y=alt.datum.median - param_width * (alt.datum.cost * 366)
        )  # 366 is the difference of score for 90% winrate for ELO
        .properties(width=800, height=450, title="frugality elo ranking")
        .configure_legend(
            labelLimit=300,
        )
    )


def draw_chart(
    frugality_infos: pl.DataFrame,
    title: str,
    scale: Literal["match", "token"] | None,
    log: bool = False,
    mean: bool = False,
    save: bool = False,
) -> alt.Chart:
    """
    Draw chart displaying Elo/BT scores against frugality scores.

    Args:
        frugality_infos (pl.DataFrame): DataFrame with frugality scores.
        title (str): Chart title.
        scale (Literal) : Select to plot mean_per_token or mean_per_match if mean=True
        log (bool): Whether or not to use a log scale.
        mean (bool): Whether or not to display total consumption or mean consumption.
        save (bool): Whether or not to save computed graph

    Returns:
        alt.Chart: Chart displaying Elo/BT scores against frugality scores.
    """
    # Dropdown to select models by license (TODO: filter by proprietary/openweights/opensource)
    input_dropdown = alt.binding_select(
        options=list(frugality_infos["license"].unique()),
        labels=[option for option in list(frugality_infos["license"].unique())],
        name="License : ",
    )
    select_license = alt.selection_point(fields=["license"], bind=input_dropdown)

    # Allow to filter by value of the legend
    select_organization = alt.selection_point(fields=["organization"], bind="legend")

    x_column = "conso_all_conv"

    if mean:
        if scale == "match":
            x_column = "mean_conso_per_match"
        elif scale == "token":
            x_column = "mean_conso_per_token"

    frugal_chart = (
        alt.Chart(frugality_infos, title=title)
        .mark_point(filled=True)
        .encode(
            alt.Y("elo_score:Q").scale(zero=False),
            alt.X(f"{x_column}:Q").scale(type="log" if log else "linear"),
            alt.Color("organization:N"),
            opacity=alt.when(select_organization).then(alt.value(1)).otherwise(alt.value(0.3)),
            tooltip=["model_name", "organization", "license", "elo_score", f"{x_column}"],
        )
        .transform_filter(select_license)
        .properties(height=300, width=500)
        .add_params(select_organization, select_license)
    )

    if save:
        save_path = Path(".").resolve().parent / "data"
        save_path.mkdir(exist_ok=True)
        file_friendly_title = "_".join(title.split())
        frugal_chart.save(fp=save_path / f"{file_friendly_title}.html", format="html")

    return frugal_chart
