# SPDX-FileCopyrightText: 2025 Pôle d'Expertise de la Régulation Numérique <contact@peren.gouv.fr>
#
# SPDX-License-Identifier: MIT

from typing import Literal

import altair as alt
import polars as pl

from rank_comparia.elo import ELORanker


def get_model_params(conversations: pl.DataFrame) -> pl.DataFrame:
    """
    Select infos about number of parameters of models

    Args:
        conversations (pl.DataFrame) : Conversations data.

    Returns:
        pl.DataFrame with number of parameters per model
    """
    return (
        pl.concat(
            [
                conversations.select(model_name=pl.col("model_a_name"), n_param=pl.col("model_a_active_params")),
                conversations.select(model_name=pl.col("model_b_name"), n_param=pl.col("model_b_active_params")),
            ]
        )
        .drop_nulls()
        .unique(subset="model_name", keep="first")
    )


def get_models_output_tokens(conversations: pl.DataFrame):
    """
    Calculates all output tokens generated by a model

    Args:
        conversations (pl.DataFrame) : Conversations data.

    Returns:
        pl.DataFrame with number of output tokens generated by model
    """
    return (
        pl.concat(
            [
                conversations.select(
                    model_name=pl.col("model_a_name"), total_output_tokens=pl.col("total_conv_a_output_tokens")
                ),
                conversations.select(
                    model_name=pl.col("model_b_name"), total_output_tokens=pl.col("total_conv_b_output_tokens")
                ),
            ]
        )
        .group_by("model_name")
        .sum()
        .sort(by="model_name")
        .drop_nulls()
    )


def get_n_match(ranker_score: ELORanker):
    return pl.DataFrame(
        zip(ranker_score.played_matches.keys(), ranker_score.played_matches.values()), schema=["model_name", "n_match"]
    ).sort(by="model_name")


def calculate_frugality_score(conversations: pl.DataFrame, n_match: pl.DataFrame, mean: bool):
    """
    Calculate a frugality score by model from conversations data.

    Args:
        conversations (pl.DataFrame): Conversations data.
        n_match (pl.DataFrame): Data with the number of matches by model.
        mean (bool): If True, compute mean energy consumption per conversation.

    Returns:
        pl.DataFrame: DataFrame with frugality scores.
    """

    frugal_score = (
        pl.concat(
            [
                conversations.select(model_name=pl.col("model_a_name"), conso_all_conv=pl.col("total_conv_a_kwh")),
                conversations.select(model_name=pl.col("model_b_name"), conso_all_conv=pl.col("total_conv_b_kwh")),
            ]
        )
        .group_by("model_name")
        .sum()
        .sort(by="model_name")
        .drop_nulls()
    )

    frugal_score = frugal_score.join(n_match, on="model_name")

    if mean:
        frugal_score = frugal_score.with_columns(
            mean_conso_per_match=pl.col("conso_all_conv") / pl.col("n_match"),
            mean_conso_per_token=pl.col("conso_all_conv") / pl.col("total_output_tokens"),
        )

    return frugal_score


def draw_chart(
    frugality_infos: pl.DataFrame,
    title: str,
    scale: Literal["match", "token"] | None,
    log: bool = False,
    mean: bool = False,
) -> alt.Chart:
    """
    Draw chart displaying Elo/BT scores against frugality scores.

    Args:
        frugality_infos (pl.DataFrame): DataFrame with frugality scores.
        title (str): Chart title.
        scale (Literal) : Select to plot mean_per_token or mean_per_match if mean=True
        log (bool): Whether or not to use a log scale.
        mean (bool): Whether or not to display total consumption or mean consumption.

    Returns:
        alt.Chart: Chart displaying Elo/BT scores against frugality scores.
    """
    # Dropdown to select models by license (TODO: filter by proprietary/openweights/opensource)
    input_dropdown = alt.binding_select(
        options=list(frugality_infos["license"].unique()),
        labels=[option for option in list(frugality_infos["license"].unique())],
        name="License : ",
    )
    select_license = alt.selection_point(fields=["license"], bind=input_dropdown)

    # Allow to filter by value of the legend
    select_organization = alt.selection_point(fields=["organization"], bind="legend")

    x_column = "conso_all_conv"

    if mean:
        if scale == "match":
            x_column = "mean_conso_per_match"
        elif scale == "token":
            x_column = "mean_conso_per_token"

    return (
        alt.Chart(frugality_infos, title=title)
        .mark_point(filled=True)
        .encode(
            alt.Y("elo_score:Q").scale(zero=False),
            alt.X(f"{x_column}:Q").scale(type="log" if log else "linear"),
            alt.Color("organization:N"),
            opacity=alt.when(select_organization).then(alt.value(1)).otherwise(alt.value(0.3)),
            tooltip=["model_name", "organization", "license", "elo_score", f"{x_column}"],
        )
        .transform_filter(select_license)
        .properties(height=300, width=500)
        .add_params(select_organization, select_license)
    )
